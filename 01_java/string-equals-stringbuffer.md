# String, equals, StringBuffer

## **Q. 자바에서 문자열을 비교할 때 == 연산자는 안되고 equals 메소드를 써야하는 이유는 무엇인가요?**

먼저, == 연산자는 객체가 실제로 위치한 메모리의 주소값을 비교하는 방식입니다. 반면에 equals() 메소드는 문자열 자체의 내용을 비교하게 됩니다. 일반적으로 우리가 자바에서 문자열을 만들 때는 큰따옴표를 사용하는 리터럴 방식을 많이 사용하는데요, 이렇게 생성된 문자열은 JVM의 String Constant Pool이라는 특별한 메모리 영역에 저장됩니다. 그런데 만약 new 연산자를 사용해서 문자열을 생성하면, 이 문자열은 힙 메모리에 새롭게 생성되기 때문에 == 연산자로 비교하면 서로 다른 메모리 주소를 가지게 되어 false를 반환하게 됩니다. 따라서 문자열의 실제 내용을 비교하고 싶다면 반드시 equals() 메소드를 사용해야 정확한 비교가 가능합니다.



## **Q. 문자열을 비교하는 equals 메소드를 구현한다면 어떻게 구현할까요?**

먼저, equals는 파라미터로 받은 객체가 String 타입인지 확인합니다. 만약 String이 아니라면 바로 false를 반환합니다. 그 다음, 두 문자열의 길이를 비교합니다. 길이가 다르다면 역시 false를 반환하구요. 마지막으로 두 문자열의 각 문자를 순회하면서 한 글자씩 비교합니다. 이때 문자열의 처음부터 끝까지 모든 문자가 동일해야 true를 반환하고, 하나라도 다른 문자가 있다면 false를 반환합니다.



## **Q.String을 생성하는 것과 StringBuffer와 StringBuilder를 이용해서 생성하는 것은 어떻게 다른가요?**

가장 큰 차이점은 '불변성'과 '가변성'입니다. String은 불변(immutable) 객체입니다. 한 번 생성된 String 객체는 내용을 변경할 수 없기 때문에, 문자열을 수정하면 새로운 String 객체가 생성됩니다. 문자열 연산이 많은 경우에는 메모리 낭비와 성능 저하가 발생할 수 있습니다. 반면에 StringBuffer와 StringBuilder는 가변(mutable) 객체입니다. 문자열을 수정할 때 객체를 새로 생성하지 않고 기존 객체의 내용을 변경합니다. 따라서 문자열 연산이 많은 경우에 더 효율적입니다. StringBuffer와 StringBuilder의 차이점은 '동기화' 지원 여부입니다. StringBuffer는 동기화를 지원하여 멀티스레드 환경에서 안전합니다(thread-safe). StringBuilder는 동기화를 지원하지 않아 단일스레드 환경에서 더 빠른 성능을 보입니다.
