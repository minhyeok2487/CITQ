# 인덱스 (Index)

## **Q. 데이터베이스 Index에 대해서 설명해주세요.**

데이터베이스 인덱스(Index) 는 테이블의 **특정 컬럼에 대한 검색 성능을 향상시키기 위해 사용하는 데이터 구조**입니다. 인덱스는 책의 색인과 유사하게, 데이터베이스가 원하는 데이터를 더 빠르게 찾을 수 있도록 도와줍니다. 인덱스가 설정된 컬럼의 값들이 정렬되어 저장되며, 이를 통해 데이터 조회 시 전체 테이블을 스캔하지 않고도 원하는 데이터를 빠르게 검색할 수 있습니다. 하지만 인덱스를 생성하면 데이터 삽입, 수정, 삭제 시 인덱스도 함께 갱신해야 하므로, 성능에 영향을 줄 수 있습니다. 적절한 인덱스 사용은 쿼리 성능을 크게 개선할 수 있지만, 과도한 인덱스는 오히려 성능 저하를 초래할 수 있습니다.

***

## **Q. Index를 설정하면 내부적으로 어떻게 동작하나요?**

데이터베이스에서 인덱스를 설정하면, 내부적으로는 해당 컬럼의 데이터를 기반으로 **B-Tree의 데이터 구조**가 생성됩니다. 데이터베이스는 인덱스 컬럼의 값을 **정렬된 트리 구조로 저장**하여, 검색 시 상위 노드부터 하위 노드로 빠르게 탐색할 수 있게 합니다. 또한, 인덱스는 해당 레코드의 실제 위치(페이지)를 포인터로 저장하여, 빠르게 데이터를 가져올 수 있도록 합니다.

***

## **Q. B-Tree 구조는 어떻게 되며 인덱스를 사용할 때와 사용하지 않을 때 시간복잡도 차이는 어떻게 되나요?**

**B-Tree는 자식 노드가 여러 개 있는 트리 구조**로, 노드가 정렬된 키 값과 포인터를 가지며, 각 노드는 특정 범위의 값을 관리합니다. 루트에서부터 시작해 키 값을 비교하며 하위 노드로 내려가는 방식으로 원하는 데이터를 탐색합니다. B-Tree의 깊이는 매우 작기 때문에 검색, 삽입, 삭제 작업 모두 평균적으로 **O(log n)의 시간복잡도**를 가집니다.

인덱스를 사용하지 않을 경우, 데이터베이스는 테이블의 모든 레코드를 순차적으로 탐색해야 하므로 검색의 **시간복잡도는 O(n)이 됩니다. 반면, 인덱스를 사용하면 B-Tree 구조 덕분에 검색 시간복잡도가 O(log n)으로 감소**하여, 대규모 데이터셋에서 검색 성능이 크게 향상됩니다.

***

## **Q. 그렇다면 인덱스의 종류에는 어떠한 것이 있나요?**

인덱스의 종류는 대표적으로 **클러스터드 인덱스(Clustered Index)** 와 **넌클러스터드 인덱스(Non-Clustered Index)** 가 있습니다.

* 클러스터드 인덱스는 테이블의 데이터가 인덱스에 따라 물리적으로 정렬되어 저장되며, 테이블당 하나만 생성할 수 있습니다.
* 반면, 넌클러스터드 인덱스는 데이터가 별도의 위치에 저장되고 인덱스는 데이터의 위치를 가리키며, 하나의 테이블에 여러 개 생성할 수 있습니다.

이외에도

* **유니크 인덱스(Unique Index)** 는 중복을 허용하지 않으며, 특정 컬럼의 값이 고유하도록 보장합니다.
* **복합 인덱스(Composite Index)** 는 여러 컬럼을 조합해 인덱스를 생성하며, 복합 검색에서 유용합니다.
* **해시 인덱스(Hash Index)** 는 정확한 값 검색에 최적화된 인덱스입니다.
* 마지막으로, **비트맵 인덱스(Bitmap Index)** 는 값의 종류가 적고 데이터 중복이 많은 컬럼에 사용됩니다.
