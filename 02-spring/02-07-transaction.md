# 트랜잭션(Transaction)

## Q. 스프링에서 트랜잭션 관리는 어떻게 이루어지나요? @Transactional 어노테이션이 동작하는 방식과 트랜잭션 전파 옵션에 대해 설명해주세요.

A. 스프링에서는 @Transactional 어노테이션을 통해 메서드나 클래스에 트랜잭션 경계를 정의하여 트랜잭션을 관리합니다.\
이 어노테이션이 적용된 메서드는 호출 시점에 트랜잭션이 시작되며, 메서드가 정상적으로 완료되면 트랜잭션을 커밋하고, 예외가 발생하면 트랜잭션을 롤백합니다.

트랜잭션 전파 옵션은 트랜잭션을 어떻게 처리할지를 지정하는데, 메서드가 호출될 때 이미 실행 중인 트랜잭션이 있는 경우 그 트랜잭션에 어떻게 반응할지를 결정합니다.\
기본 전파 옵션은 `REQUIRED`로, 현재 실행 중인 트랜잭션이 있으면 그 트랜잭션에 참여하고, 없으면 새 트랜잭션을 시작합니다.\
기타 전파 옵션으로는 `REQUIRES_NEW`(항상 새로운 트랜잭션을 생성), `SUPPORTS`(트랜잭션이 있으면 참여, 없으면 비트랜잭션 방식으로 실행),\
`MANDATORY`(현재 트랜잭션이 있어야만 실행), `NOT_SUPPORTED`(트랜잭션 없이 실행), `NEVER`(트랜잭션이 있으면 예외 발생) 등이 있습니다.

***

## Q. 스프링 트랜잭션에서 롤백이 발생하면 어떤 일이 일어나나요?

A. 스프링 트랜잭션에서 롤백이 발생하면 트랜잭션 내에서 이루어진 모든 변경 사항이 취소됩니다.\
즉, 트랜잭션 내에서 실행된 데이터베이스 작업이 원래 상태로 되돌아갑니다. 이를 통해 데이터베이스의 일관성과 무결성이 유지됩니다.\
롤백은 스프링의 `AOP(Aspect-Oriented Programming)`를 통해 구현되며, 런타임 예외(언체크 예외)가 발생하면 자동으로 트랜잭션을 롤백합니다.\
개발자는 `@Transactional` 어노테이션의 `rollbackFor` 속성을 사용해 특정 예외 발생 시 롤백을 명시적으로 설정할 수 있습니다.

***

## Q. 트랜잭션 처리 시 자바 메모리 구조에서 어떤 영역이 영향을 받나요?

A. 트랜잭션 처리 시 주로 영향을 받는 메모리 영역은 `Heap`과 `Stack`입니다.

* `Heap Area`: 트랜잭션 중 객체의 상태 변경은 힙에 반영됩니다. 데이터베이스와의 상호작용에서 생성된 엔티티 객체나 서비스 로직에서 변경된 상태가 힙에 저장됩니다.
* `Stack Area`: 메서드 호출 시 사용되며, 트랜잭션 처리 중에 메서드 호출의 흐름과 지역 변수가 여기에 저장됩니다.\
  트랜잭션 처리 시 메모리 구조에 큰 영향을 미치지 않는 영역으로는 `Method Area`, `Native Method Stack`, `PC Register` 등이 있습니다.

이들은 주로 트랜잭션과는 무관하게 클래스 정보나 메소드 정보, 네이티브 메소드의 처리에 사용됩니다.

***

## Q. 스프링 트랜잭션에서 `격리 수준(Isolation Level)`에 대해 설명해주세요.

A. 트랜잭션의 격리 수준은 동시에 여러 트랜잭션이 수행될 때 데이터 간의 간섭을 제어하는 데 사용됩니다. 스프링에서 설정할 수 있는 격리 수준은 다음과 같습니다:

* `READ_UNCOMMITTED`: 트랜잭션이 커밋되지 않은 변경 사항도 다른 트랜잭션에서 읽을 수 있습니다. Dirty Read가 발생할 수 있습니다.
* `READ_COMMITTED`: 트랜잭션이 커밋한 변경 사항만 다른 트랜잭션에서 읽을 수 있습니다. Dirty Read를 방지합니다.
* `REPEATABLE_READ`: 트랜잭션 내에서 동일한 데이터를 반복해서 읽을 때 항상 같은 결과를 보장합니다. Non-repeatable Read를 방지합니다.
* `SERIALIZABLE`: 가장 높은 격리 수준으로, 트랜잭션 간의 간섭을 완전히 방지하며, 트랜잭션들이 직렬화된 것처럼 처리됩니다. 성능에 큰 영향을 미칩니다.\
  기본 격리 수준은 사용 중인 데이터베이스에 따라 다르며, 스프링 설정이나 `@Transactional` 속성을 통해 명시적으로 격리 수준을 설정할 수 있습니다.
